# GitHub Actions workflow for deploying MCP Workshop Labs to AWS
name: Deploy MCP Workshop Lab to AWS

on:
  workflow_dispatch:
    inputs:
      lab_number:
        description: 'Lab number to deploy'
        required: true
        default: '3'
        type: choice
        options:
          - '3'
      aws_region:
        description: 'AWS Region to deploy to'
        required: true
        default: 'us-west-2'
        type: choice
        options:
          - us-east-1
          - us-east-2
          - us-west-1
          - us-west-2
          - eu-west-1
          - eu-central-1
          - ap-northeast-1
          - ap-southeast-1
          - ap-southeast-2

env:
  TF_WORKING_DIR: ${{ format('./lab0{0}-aws-cloud-deployment/terraform', inputs.lab_number) }}
  PRODUCT_SERVER_DIR: ${{ format('./lab0{0}-aws-cloud-deployment/src/product-server', inputs.lab_number) }}
  ORDER_SERVER_DIR: ${{ format('./lab0{0}-aws-cloud-deployment/src/order-server', inputs.lab_number) }}
  MCP_PLAYGROUND_DIR: ${{ format('./lab0{0}-aws-cloud-deployment/src/mcp-playground', inputs.lab_number) }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ github.event.inputs.aws_region }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Create S3 bucket for Terraform state
        run: |
          # Create S3 bucket for Terraform state if it doesn't exist
          aws s3api head-bucket --bucket mcp-workshop-tf-state-${{ github.repository_owner }} 2>/dev/null || \
          aws s3api create-bucket \
            --bucket mcp-workshop-tf-state-${{ github.repository_owner }} \
            --region ${{ github.event.inputs.aws_region }} \
            --create-bucket-configuration LocationConstraint=${{ github.event.inputs.aws_region }}
          
          # Enable versioning on the bucket
          aws s3api put-bucket-versioning \
            --bucket mcp-workshop-tf-state-${{ github.repository_owner }} \
            --versioning-configuration Status=Enabled
      
      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init \
            -backend-config="bucket=mcp-workshop-tf-state-${{ github.repository_owner }}" \
            -backend-config="key=lab0${{ github.event.inputs.lab_number }}/terraform.tfstate" \
            -backend-config="region=${{ github.event.inputs.aws_region }}"

      - name: Terraform Apply ECR Only
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Create only the ECR repositories first
          terraform apply -auto-approve -var="aws_region=${{ github.event.inputs.aws_region }}" -var="github_repository=${{ github.repository }}" -target=aws_ecr_repository.mcp_playground_repository

      - name: Set ECR Repository URLs
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Extract ECR repository URLs
          MCP_PLAYGROUND_ECR_REPO=$(terraform output -raw mcp_playground_repository_url 2>/dev/null || aws ecr describe-repositories --repository-names mcp-playground --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "***.dkr.ecr.${{ github.event.inputs.aws_region }}.amazonaws.com/mcp-playground")
          
          # Set environment variables for later steps
          echo "MCP_PLAYGROUND_ECR_REPO=$MCP_PLAYGROUND_ECR_REPO" >> $GITHUB_ENV
          echo "ECR Repository: $MCP_PLAYGROUND_ECR_REPO"
          
          # Validate ECR repository URLs
          if [ -z "$MCP_PLAYGROUND_ECR_REPO" ]; then
            echo "Error: Failed to get ECR repository URLs"
            exit 1
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and Push MCP Playground Docker Image
        uses: docker/build-push-action@v4
        with:
          context: ${{ env.MCP_PLAYGROUND_DIR }}
          push: true
          tags: ${{ env.MCP_PLAYGROUND_ECR_REPO }}:latest
          no-cache: true

      - name: Install Node.js for Lambda functions
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies for Product Server
        working-directory: ${{ env.PRODUCT_SERVER_DIR }}
        run: npm install

      - name: Install dependencies for Order Server
        working-directory: ${{ env.ORDER_SERVER_DIR }}
        run: npm install

      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Now deploy the rest of the infrastructure
          terraform apply -auto-approve -var="aws_region=${{ github.event.inputs.aws_region }}" -var="github_repository=${{ github.repository }}"
          
      - name: Update ECS Service
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Set default region if not provided
          export AWS_DEFAULT_REGION=${{ github.event.inputs.aws_region }}
          
          # Verify ECS services exist before updating
          echo "Verifying ECS services exist before updating..."
          SERVICES=$(aws ecs list-services --cluster mcp-workshop-cluster || echo '{"serviceArns":[]}')
          
          # Check if the services list contains mcp-playground
          if echo "$SERVICES" | grep -q "mcp-playground"; then
            echo "Updating mcp-playground service..."
            aws ecs update-service --cluster mcp-workshop-cluster --service mcp-playground --force-new-deployment
            
            # Wait for services to stabilize
            echo "Waiting for services to stabilize..."
            aws ecs wait services-stable --cluster mcp-workshop-cluster --services mcp-playground || echo "Warning: Not all services stabilized, but continuing workflow"
          else
            echo "MCP Playground service not found yet. This is expected on first deployment."
            echo "The service will be created by Terraform in the next step."
          fi

      - name: Get Endpoints
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # List all available outputs
          echo "Available Terraform outputs:"
          terraform output || echo "No outputs available yet"
          
          # Get the MCP Playground ALB DNS name with fallback
          MCP_PLAYGROUND_ALB=$(terraform output -raw mcp_playground_url 2>/dev/null | grep -o '[^:]*\.elb\.amazonaws\.com' | head -1 || echo "pending-mcp-playground-alb")
          
          # Get the Lambda-based MCP server endpoints with fallbacks
          PRODUCT_LAMBDA_ENDPOINT=$(terraform output -raw product_server_endpoint 2>/dev/null || echo "pending-product-endpoint")
          ORDER_LAMBDA_ENDPOINT=$(terraform output -raw order_server_endpoint 2>/dev/null || echo "pending-order-endpoint")
          
          # Set the environment variables even if they're pending
          # This allows the workflow to continue and we'll update the actual values later
          echo "MCP_PLAYGROUND_ALB=$MCP_PLAYGROUND_ALB" >> $GITHUB_ENV
          echo "PRODUCT_LAMBDA_ENDPOINT=$PRODUCT_LAMBDA_ENDPOINT" >> $GITHUB_ENV
          echo "ORDER_LAMBDA_ENDPOINT=$ORDER_LAMBDA_ENDPOINT" >> $GITHUB_ENV
          
          echo "MCP Playground ALB: $MCP_PLAYGROUND_ALB"
          echo "Product Lambda Endpoint: $PRODUCT_LAMBDA_ENDPOINT"
          echo "Order Lambda Endpoint: $ORDER_LAMBDA_ENDPOINT"
          
          # Continue the workflow even if endpoints are pending
          echo "Deployment in progress. Some endpoints may not be available yet."

      - name: Output Deployment Information
        run: |
          echo "\nðŸš€ Deployment Complete! ðŸš€\n"
          echo "MCP Workshop has been successfully deployed to AWS."
          
          # Only show URLs if they're available (not pending)
          if [[ "${{ env.MCP_PLAYGROUND_ALB }}" != pending* ]]; then
            echo "\nAccess your MCP Playground at: http://${{ env.MCP_PLAYGROUND_ALB }}"
          else
            echo "\nMCP Playground URL will be available soon. Check AWS Console for details."
          fi
          
          echo "\nAPI Endpoints:"
          if [[ "${{ env.PRODUCT_LAMBDA_ENDPOINT }}" != pending* ]]; then
            echo "- Product Server: ${{ env.PRODUCT_LAMBDA_ENDPOINT }}"
          else
            echo "- Product Server: Endpoint will be available soon"
          fi
          
          if [[ "${{ env.ORDER_LAMBDA_ENDPOINT }}" != pending* ]]; then
            echo "- Order Server: ${{ env.ORDER_LAMBDA_ENDPOINT }}"
          else
            echo "- Order Server: Endpoint will be available soon"
          fi
          
          echo "\nThese endpoints are configured in the MCP Playground application."
          echo "You can now use the MCP Playground to interact with the MCP servers."
          echo ""
          echo "Claude Desktop Configuration:"
          echo '{
            "mcpServers": {
              "aws-product-server": {
                "url": "'"${{ env.PRODUCT_LAMBDA_ENDPOINT }}"'"
              },
              "aws-order-server": {
                "url": "'"${{ env.ORDER_LAMBDA_ENDPOINT }}"'"
              }
            }
          }'
          echo ""
          echo "MCP Workshop Implementation:"
          echo "This deployment uses:"
          echo "- Serverless MCP servers running on AWS Lambda"
          echo "- Container-based MCP Playground running on ECS/Fargate"
          echo ""
          echo "This approach gives you the flexibility to test both local and cloud-based clients."
